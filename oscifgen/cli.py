# oscifgen/cli.py
import argparse

from .reader import Reader
from .writer import Writer
from .file_device import FileDevice
from .mic_device import MicrophoneDevice
from .wavegen import Wave
from .script_runner import ScriptRunner


def run_command(args: argparse.Namespace) -> None:
    runner = ScriptRunner(args.script)
    runner.run()


def main() -> None:
    p = argparse.ArgumentParser(
        prog="oscifgen",
        description="Oscilloscope & Function Generator (Python)",
    )
    sub = p.add_subparsers(dest="cmd", required=True)

    # --- acquire: reqfRead ---
    p_acq = sub.add_parser(
        "acquire", help="reqfRead: read from input and write to output file")
    p_acq.add_argument("--in", dest="in_path", required=True,
                       help="Input source: .in file or the literal 'mic' for microphone")
    p_acq.add_argument("--out", dest="out_path", required=True,
                       help="Output file to write captured bytes")
    p_acq.add_argument("--fs", type=float, required=True,
                       help="Sampling frequency in Hz")
    p_acq.add_argument("--n", type=int, default=None,
                       help="Total number of bytes to read")
    p_acq.add_argument("--loops", type=int, default=None,
                       help="Loop count (alternative termination condition)")
    p_acq.add_argument("--chunk", type=int, default=512,
                       help="Chunk size in bytes per read")

    # --- generate: reqfWrite ---
    p_gen = sub.add_parser(
        "generate", help="reqfWrite: generate waveform bytes to output")
    p_gen.add_argument("--out", dest="out_path", required=True,
                       help="Output file for generated bytes")
    p_gen.add_argument("--fo", type=float, required=True,
                       help="Output frequency in Hz")
    p_gen.add_argument("--wave", choices=["sine", "square", "triangle"], default="sine",
                       help="Waveform type")
    p_gen.add_argument("--amp", type=float, default=1.0,
                       help="Wave amplitude (unitless)")
    p_gen.add_argument("--n", type=int, default=None,
                       help="Total number of bytes to write")
    p_gen.add_argument("--loops", type=int, default=None,
                       help="Loop count (alternative termination)")
    p_gen.add_argument("--chunk", type=int, default=512,
                       help="Chunk size in bytes per write")

    # --- run: script mode ---
    p_script = sub.add_parser(
        "run", help="Run a JSON script of read/write commands")
    p_script.add_argument("--script", required=True,
                          help="Path to JSON script file")

    args = p.parse_args()

    if args.cmd == "run":
        run_command(args)
        return

    if args.cmd == "acquire":
        # Decide which device to use based on the --in argument
        if args.in_path.lower().startswith("mic"):
            dev = MicrophoneDevice()
        else:
            dev = FileDevice()

        Reader().run(
            dev=dev,
            in_path=args.in_path,
            out_path=args.out_path,
            fs=args.fs,
            n=args.n,
            loops=args.loops,
            chunk=args.chunk,
        )
        return

    if args.cmd == "generate":
        dev = FileDevice()
        w = {"sine": Wave.SINE,
             "square": Wave.SQUARE,
             "triangle": Wave.TRIANGLE}[args.wave]

        Writer().run(
            dev=dev,
            out_path=args.out_path,
            fo=args.fo,
            wave=w,
            amp=args.amp,
            n=args.n,
            loops=args.loops,
            chunk=args.chunk,
        )
        return
